name: Deploy to EC2 (stage/prod)

on:
  push:
    branches: ["stage", "prod"]

env:
  AWS_REGION: us-east-1
  ECR_REPO: edxco/properlia
  IMAGE_NAME: properlia-api
  DOCKER_BUILDKIT: 1

jobs:
  deploy:
    runs-on: ubuntu-latest
    # environment: ${{ github.ref_name }}

    permissions:
      id-token: write # for AWS OIDC
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Debug ref and actor
        run: |
          echo "GITHUB_REF=${GITHUB_REF}"
          echo "GITHUB_REF_NAME=${GITHUB_REF_NAME}"
          echo "Expect trust policy sub=repo:${{ github.repository }}:ref:refs/heads/${GITHUB_REF_NAME}"

        # --- Fail-fast guard (before AWS credentials setup) ---
      - name: Assert AWS_ROLE_ARN is present
        run: |
          if [ -z "${{ secrets.AWS_ROLE_ARN }}" ]; then
            echo "❌ Missing AWS_ROLE_ARN secret"; exit 1
          else
            echo "✅ AWS_ROLE_ARN secret found"
          fi

      # --- AWS login via OIDC (recommended) ---
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }} # IAM role with ECR push perms
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set env per branch (stage/prod)
        id: envmap
        run: |
          if [ "${GITHUB_REF_NAME}" = "stage" ]; then
            echo "ENV_NAME=stage" >> $GITHUB_OUTPUT
            echo "EC2_HOST=${{ secrets.STAGE_EC2_HOST }}" >> $GITHUB_OUTPUT
            echo "EC2_USER=${{ secrets.EC2_SSH_USER }}" >> $GITHUB_OUTPUT
            echo "EC2_PATH=${{ secrets.STAGE_EC2_PATH }}" >> $GITHUB_OUTPUT
            echo "ENV_FILE=.env.stage" >> $GITHUB_OUTPUT
            echo "COMPOSE_FILE=docker-compose.stage.yml" >> $GITHUB_OUTPUT
            echo "PORT=3000" >> $GITHUB_OUTPUT
          else
            echo "ENV_NAME=prod" >> $GITHUB_OUTPUT
            echo "EC2_HOST=${{ secrets.PROD_EC2_HOST }}" >> $GITHUB_OUTPUT
            echo "EC2_USER=${{ secrets.EC2_SSH_USER }}" >> $GITHUB_OUTPUT
            echo "EC2_PATH=${{ secrets.PROD_EC2_PATH }}" >> $GITHUB_OUTPUT
            echo "ENV_FILE=.env.prod" >> $GITHUB_OUTPUT
            echo "COMPOSE_FILE=docker-compose.prod.yml" >> $GITHUB_OUTPUT
            echo "PORT=3000" >> $GITHUB_OUTPUT
          fi

      - name: Verify deploy artifacts exist
        id: check
        run: |
          set -e
          echo "Expecting compose file: ${{ steps.envmap.outputs.COMPOSE_FILE }}"
          ls -la
          test -f "./${{ steps.envmap.outputs.COMPOSE_FILE }}" || (echo "❌ Missing compose file at repo root"; exit 1)

          if [ -f "./${{ steps.envmap.outputs.ENV_FILE }}" ]; then
            echo "✅ Found env file in repo: ${{ steps.envmap.outputs.ENV_FILE }}"
            echo "COPY_ENV=true" >> "$GITHUB_OUTPUT"
          else
            echo "ℹ️ Env file not in repo: ${{ steps.envmap.outputs.ENV_FILE }} (will create on EC2)"
            echo "COPY_ENV=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Compute image tags
        id: vars
        run: |
          SHA_SHORT=$(echo "${GITHUB_SHA}" | cut -c1-7)
          REGISTRY="${{ steps.ecr.outputs.registry }}"
          IMAGE_URI="$REGISTRY/${{ env.ECR_REPO }}:${GITHUB_REF_NAME}-${SHA_SHORT}"
          echo "IMAGE_URI=$IMAGE_URI" >> $GITHUB_OUTPUT
          echo "SHA_SHORT=$SHA_SHORT" >> $GITHUB_OUTPUT

      # --- Build & push image to ECR ---
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: |
            ${{ steps.vars.outputs.IMAGE_URI }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Map SG per branch
      - name: Map SG per env
        id: sg
        run: |
          if [ "${GITHUB_REF_NAME}" = "stage" ]; then
            echo "SG_ID=${{ secrets.STAGE_SG_ID }}" >> $GITHUB_OUTPUT
          else
            echo "SG_ID=${{ secrets.PROD_SG_ID }}" >> $GITHUB_OUTPUT
          fi

      # Allow runner IP on port 22
      - name: Allow SSH from this runner IP
        if: success()
        run: |
          set -e
          MYIP="$(curl -s https://checkip.amazonaws.com)/32"
          echo "Allowing ${MYIP} on SG ${SG_ID}"
          aws ec2 authorize-security-group-ingress \
            --group-id "${{ steps.sg.outputs.SG_ID }}" \
            --protocol tcp --port 22 --cidr "${MYIP}" || true
        env:
          SG_ID: ${{ steps.sg.outputs.SG_ID }}

      # --- Copy deploy files to EC2 (compose + env files, if you keep them in repo) ---
      # (Skip if these already live on the instance)
      - name: Copy docker-compose and env to EC2
        if: success()
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ steps.envmap.outputs.EC2_HOST }}
          username: ${{ steps.envmap.outputs.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          source: |
            ./${{ steps.envmap.outputs.COMPOSE_FILE }}
            ${{ steps.check.outputs.COPY_ENV == 'true' && format('./{0}', steps.envmap.outputs.ENV_FILE) || '' }}
          target: ${{ steps.envmap.outputs.EC2_PATH }}
          debug: true

      # --- Deploy on EC2 ---
      - name: Deploy on EC2 (pull, up, migrate)
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ steps.envmap.outputs.EC2_HOST }}
          username: ${{ steps.envmap.outputs.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -euo pipefail
            cd "${{ steps.envmap.outputs.EC2_PATH }}"

            # Login to ECR (instance role recommended; fallback uses docker login)
            aws --version >/dev/null 2>&1 && \
              aws ecr get-login-password --region ${{ env.AWS_REGION }} \
              | docker login --username AWS --password-stdin ${{ steps.ecr.outputs.registry }} || true

            export IMAGE="${{ steps.vars.outputs.IMAGE_URI }}"
            export PORT="${{ steps.envmap.outputs.PORT }}"
            export ENV_FILE="${{ steps.envmap.outputs.ENV_FILE }}"
            export COMPOSE_FILE="${{ steps.envmap.outputs.COMPOSE_FILE }}"

            echo "Using IMAGE=$IMAGE"
            echo "Using COMPOSE_FILE=$COMPOSE_FILE"
            docker pull "$IMAGE"

            # Ensure compose is present (Compose V2)
            docker compose version || sudo curl -L "https://github.com/docker/compose/releases/download/v2.29.7/docker-compose-linux-x86_64" -o /usr/local/bin/docker-compose && sudo chmod +x /usr/local/bin/docker-compose

            # Bring up (remove orphans, recreate changed)
            docker compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" up -d --remove-orphans

            # Run DB migrations
            docker compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" run --rm web bundle exec rails db:migrate

            # Cleanup old images
            docker image prune -f
      - name: Write env file on EC2 when missing
        if: steps.check.outputs.COPY_ENV == 'false'
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ steps.envmap.outputs.EC2_HOST }}
          username: ${{ steps.envmap.outputs.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -euo pipefail
            cd "${{ steps.envmap.outputs.EC2_PATH }}"
            cat > "${{ steps.envmap.outputs.ENV_FILE }}" << 'EOF'
            PORT=${{ steps.envmap.outputs.PORT }}
            RAILS_ENV=${{ secrets.RAILS_ENV }}
            DATABASE_URL=${{ secrets.DATABASE_URL }}
            SECRET_KEY_BASE=${{ secrets.SECRET_KEY_BASE }}
            RAILS_MAX_THREADS=${{ secrets.RAILS_MAX_THREADS }}
            RAILS_SERVE_STATIC_FILES=${{ secrets.RAILS_SERVE_STATIC_FILES }}
            RAILS_LOG_TO_STDOUT=${{ secrets.RAILS_LOG_TO_STDOUT }}
            ACTIVE_STORAGE_SERVICE=${{ secrets.ACTIVE_STORAGE_SERVICE }}
            AWS_REGION=${{ env.AWS_REGION }}
            AWS_BUCKET=${{ secrets.AWS_BUCKET }}
            DEVISE_JWT_SECRET_KEY=${{ secrets.DEVISE_JWT_SECRET_KEY }}
            CORS_ORIGINS=${{ secrets.CORS_ORIGINS }}
            POSTGRES_USER=${{ secrets.POSTGRES_USER }}
            POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
            POSTGRES_DB=${{ secrets.POSTGRES_DB }}
            EOF

      - name: Revoke SSH from this runner IP
        if: always()
        run: |
          set -e
          MYIP="$(curl -s https://checkip.amazonaws.com)/32"
          echo "Revoking ${MYIP} on SG ${SG_ID}"
          aws ec2 revoke-security-group-ingress \
            --group-id "${{ steps.sg.outputs.SG_ID }}" \
            --protocol tcp --port 22 --cidr "${MYIP}" || true
        env:
          SG_ID: ${{ steps.sg.outputs.SG_ID }}
