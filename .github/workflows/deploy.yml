name: Migrate & Deploy (Proper API)

on:
  push:
    branches: ["stage", "production"]
  workflow_dispatch:

jobs:
  migrate-and-deploy:
    runs-on: ubuntu-latest

    # Asignamos el Environment de GitHub seg√∫n la rama
    environment: ${{ github.ref_name }}  # 'stage' o 'production'

    permissions:
      id-token: write   # OIDC
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Debug repo/ref
        run: |
          echo "GITHUB_REPOSITORY=$GITHUB_REPOSITORY"   # Owner/Repo exactos
          echo "GITHUB_REF=$GITHUB_REF"                 # refs/heads/stage

      - name: Debug GitHub ref
        run: |
          echo "GITHUB_REF=$GITHUB_REF"
          echo "GITHUB_REF_NAME=$GITHUB_REF_NAME"
          echo "GITHUB_EVENT_NAME=$GITHUB_EVENT_NAME"

      - name: Select Rails env (staging vs production)
        run: |
          if [ "${{ github.ref_name }}" = "production" ]; then
            echo "RAILS_ENV=production" >> $GITHUB_ENV
          else
            echo "RAILS_ENV=staging" >> $GITHUB_ENV
          fi

      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.2"        # ajusta a tu versi√≥n
          bundler-cache: true

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Fetch secrets from AWS Secrets Manager (JSON DB + encode password safely)
        id: sm
        env:
          DB_SECRET_ID: ${{ secrets.DATABASE_URL }}         # ID/ARN del secreto JSON
          DB_JSON_KEY: STAGE_DATABASE_URL                   # clave dentro del JSON
          MASTER_SECRET_ID: ${{ secrets.RAILS_MASTER_KEY }} # ID/ARN del secreto JSON o texto plano
        run: |
          set -euo pipefail
          command -v jq >/dev/null || { sudo apt-get update -y && sudo apt-get install -y jq; }

          # --- DB URL desde JSON ---
          RAW_DB=$(aws secretsmanager get-secret-value --secret-id "$DB_SECRET_ID" --query 'SecretString' --output text)
          DB_URL=$(jq -r --arg k "$DB_JSON_KEY" '.[$k] // empty' <<< "$RAW_DB")
          if [ -z "$DB_URL" ]; then
            echo "üîé Claves disponibles en el secreto de DB:" >&2
            jq -r 'keys[]' <<< "$RAW_DB" >&2
            echo "::error::Key '$DB_JSON_KEY' missing or empty in DB secret JSON"
            exit 1
          fi

          # --- Encodificar SOLO el password, sin parsear la URL completa ---
          DB_URL_SAFE=$(ruby - "$DB_URL" <<'RUBY'
            raw = ARGV[0]
            # schema://userinfo@rest  (userinfo = user[:password])
            m = raw.match(/\A([a-z][a-z0-9+.\-]*):\/\/([^@]+)@(.+)\z/i)
            unless m
              # Si no hay userinfo (sin '@'), devuelve igual
              puts raw
              exit
            end
            scheme, userinfo, rest = m.captures
            user, pass = userinfo.split(":", 2)  # solo primer ':'
            require "uri"
            if pass
              pass = URI.encode_www_form_component(pass) # %23, %24, %25, etc.
              userinfo = "#{user}:#{pass}"
            else
              userinfo = user
            end
            puts "#{scheme}://#{userinfo}@#{rest}"
          RUBY
          )

              echo "::add-mask::$DB_URL_SAFE"
              echo "DATABASE_URL=$DB_URL_SAFE" >> "$GITHUB_ENV"

              # --- Master key / Secret key base ---
              RAW_MASTER=$(aws secretsmanager get-secret-value --secret-id "$MASTER_SECRET_ID" --query 'SecretString' --output text)

              # Soporta JSON { "RAILS_MASTER_KEY": "..."} o texto plano
              if [[ "$RAW_MASTER" =~ ^\{ ]]; then
                MASTER=$(jq -r '.RAILS_MASTER_KEY // .SECRET_KEY_BASE // empty' <<< "$RAW_MASTER")
              else
                MASTER="$RAW_MASTER"
              fi
              [ -n "$MASTER" ] || { echo "::error::MASTER secret empty"; exit 1; }

              echo "::add-mask::$MASTER"
              echo "RAILS_MASTER_KEY=$MASTER" >> "$GITHUB_ENV"

      - name: Sanity check Logger
        run: ruby -e 'require "logger"; puts Logger::Severity.constants.map(&:to_s).join(",")'
        
      - name: Verify DB connectivity (optional)
        run: |
          ruby -e "require 'uri'; u=URI(ENV['DATABASE_URL']); puts \"Connecting to #{u.host}:#{u.port}#{u.path}\""

      # Si tu DB ya existe en RDS, usa db:migrate; evita db:prepare para no requerir CREATEDB.
      - name: Run migrations
        env:
          RAILS_ENV: ${{ env.RAILS_ENV }}
        run: |
          bundle exec rails db:migrate
          bundle exec rails db:abort_if_pending_migrations

      # Si App Runner est√° conectado a tu repo y auto-construye con push,
      # este paso es opcional. Si quieres forzar el despliegue inmediato:
      - name: Trigger App Runner deployment
        run: |
          aws apprunner start-deployment --service-arn "${{ secrets.APP_RUNNER_SERVICE_ARN }}"
